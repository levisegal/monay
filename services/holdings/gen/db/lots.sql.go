// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: lots.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createLot = `-- name: CreateLot :one
insert into monay.lots (
    id,
    account_id,
    security_id,
    transaction_id,
    acquired_date,
    quantity_micros,
    remaining_micros,
    cost_basis_micros
) values (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8
)
returning id, account_id, security_id, transaction_id, acquired_date, quantity_micros, remaining_micros, cost_basis_micros, created_at
`

type CreateLotParams struct {
	ID              string      `json:"id"`
	AccountID       string      `json:"account_id"`
	SecurityID      string      `json:"security_id"`
	TransactionID   string      `json:"transaction_id"`
	AcquiredDate    pgtype.Date `json:"acquired_date"`
	QuantityMicros  int64       `json:"quantity_micros"`
	RemainingMicros int64       `json:"remaining_micros"`
	CostBasisMicros int64       `json:"cost_basis_micros"`
}

func (q *Queries) CreateLot(ctx context.Context, arg CreateLotParams) (MonayLot, error) {
	row := q.db.QueryRow(ctx, createLot,
		arg.ID,
		arg.AccountID,
		arg.SecurityID,
		arg.TransactionID,
		arg.AcquiredDate,
		arg.QuantityMicros,
		arg.RemainingMicros,
		arg.CostBasisMicros,
	)
	var i MonayLot
	err := row.Scan(
		&i.ID,
		&i.AccountID,
		&i.SecurityID,
		&i.TransactionID,
		&i.AcquiredDate,
		&i.QuantityMicros,
		&i.RemainingMicros,
		&i.CostBasisMicros,
		&i.CreatedAt,
	)
	return i, err
}

const createLotDisposition = `-- name: CreateLotDisposition :one
insert into monay.lot_dispositions (
    id,
    lot_id,
    sell_transaction_id,
    disposed_date,
    quantity_micros,
    cost_basis_micros,
    proceeds_micros,
    realized_gain_micros,
    holding_period
) values (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8,
    $9
)
returning id, lot_id, sell_transaction_id, disposed_date, quantity_micros, cost_basis_micros, proceeds_micros, realized_gain_micros, holding_period, created_at
`

type CreateLotDispositionParams struct {
	ID                 string      `json:"id"`
	LotID              string      `json:"lot_id"`
	SellTransactionID  string      `json:"sell_transaction_id"`
	DisposedDate       pgtype.Date `json:"disposed_date"`
	QuantityMicros     int64       `json:"quantity_micros"`
	CostBasisMicros    int64       `json:"cost_basis_micros"`
	ProceedsMicros     int64       `json:"proceeds_micros"`
	RealizedGainMicros int64       `json:"realized_gain_micros"`
	HoldingPeriod      string      `json:"holding_period"`
}

func (q *Queries) CreateLotDisposition(ctx context.Context, arg CreateLotDispositionParams) (MonayLotDisposition, error) {
	row := q.db.QueryRow(ctx, createLotDisposition,
		arg.ID,
		arg.LotID,
		arg.SellTransactionID,
		arg.DisposedDate,
		arg.QuantityMicros,
		arg.CostBasisMicros,
		arg.ProceedsMicros,
		arg.RealizedGainMicros,
		arg.HoldingPeriod,
	)
	var i MonayLotDisposition
	err := row.Scan(
		&i.ID,
		&i.LotID,
		&i.SellTransactionID,
		&i.DisposedDate,
		&i.QuantityMicros,
		&i.CostBasisMicros,
		&i.ProceedsMicros,
		&i.RealizedGainMicros,
		&i.HoldingPeriod,
		&i.CreatedAt,
	)
	return i, err
}

const deleteLotsByAccount = `-- name: DeleteLotsByAccount :exec
DELETE FROM monay.lot_dispositions
WHERE lot_id IN (SELECT id FROM monay.lots WHERE account_id = $1)
`

func (q *Queries) DeleteLotsByAccount(ctx context.Context, accountID string) error {
	_, err := q.db.Exec(ctx, deleteLotsByAccount, accountID)
	return err
}

const deleteLotsForAccount = `-- name: DeleteLotsForAccount :exec
DELETE FROM monay.lots
WHERE account_id = $1
`

func (q *Queries) DeleteLotsForAccount(ctx context.Context, accountID string) error {
	_, err := q.db.Exec(ctx, deleteLotsForAccount, accountID)
	return err
}

const getLot = `-- name: GetLot :one
select id, account_id, security_id, transaction_id, acquired_date, quantity_micros, remaining_micros, cost_basis_micros, created_at
from monay.lots
where id = $1
`

func (q *Queries) GetLot(ctx context.Context, id string) (MonayLot, error) {
	row := q.db.QueryRow(ctx, getLot, id)
	var i MonayLot
	err := row.Scan(
		&i.ID,
		&i.AccountID,
		&i.SecurityID,
		&i.TransactionID,
		&i.AcquiredDate,
		&i.QuantityMicros,
		&i.RemainingMicros,
		&i.CostBasisMicros,
		&i.CreatedAt,
	)
	return i, err
}

const listAllHoldings = `-- name: ListAllHoldings :many
select
    a.name as account_name,
    s.symbol,
    s.name as security_name,
    sum(l.remaining_micros)::bigint as quantity_micros,
    sum(
        case when l.remaining_micros > 0 
        then (l.cost_basis_micros::float / l.quantity_micros::float * l.remaining_micros::float)::bigint
        else 0 end
    )::bigint as cost_basis_micros,
    min(l.acquired_date) as earliest_acquired
from monay.lots l
join monay.securities s on s.id = l.security_id
join monay.accounts a on a.id = l.account_id
where l.remaining_micros > 0
group by a.name, s.symbol, s.name
order by cost_basis_micros desc
`

type ListAllHoldingsRow struct {
	AccountName      string      `json:"account_name"`
	Symbol           string      `json:"symbol"`
	SecurityName     pgtype.Text `json:"security_name"`
	QuantityMicros   int64       `json:"quantity_micros"`
	CostBasisMicros  int64       `json:"cost_basis_micros"`
	EarliestAcquired interface{} `json:"earliest_acquired"`
}

func (q *Queries) ListAllHoldings(ctx context.Context) ([]ListAllHoldingsRow, error) {
	rows, err := q.db.Query(ctx, listAllHoldings)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListAllHoldingsRow{}
	for rows.Next() {
		var i ListAllHoldingsRow
		if err := rows.Scan(
			&i.AccountName,
			&i.Symbol,
			&i.SecurityName,
			&i.QuantityMicros,
			&i.CostBasisMicros,
			&i.EarliestAcquired,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDispositionsBySellTransaction = `-- name: ListDispositionsBySellTransaction :many
select
    d.id, d.lot_id, d.sell_transaction_id, d.disposed_date, d.quantity_micros, d.cost_basis_micros, d.proceeds_micros, d.realized_gain_micros, d.holding_period, d.created_at,
    l.acquired_date,
    l.security_id
from monay.lot_dispositions d
join monay.lots l on l.id = d.lot_id
where d.sell_transaction_id = $1
`

type ListDispositionsBySellTransactionRow struct {
	ID                 string             `json:"id"`
	LotID              string             `json:"lot_id"`
	SellTransactionID  string             `json:"sell_transaction_id"`
	DisposedDate       pgtype.Date        `json:"disposed_date"`
	QuantityMicros     int64              `json:"quantity_micros"`
	CostBasisMicros    int64              `json:"cost_basis_micros"`
	ProceedsMicros     int64              `json:"proceeds_micros"`
	RealizedGainMicros int64              `json:"realized_gain_micros"`
	HoldingPeriod      string             `json:"holding_period"`
	CreatedAt          pgtype.Timestamptz `json:"created_at"`
	AcquiredDate       pgtype.Date        `json:"acquired_date"`
	SecurityID         string             `json:"security_id"`
}

func (q *Queries) ListDispositionsBySellTransaction(ctx context.Context, sellTransactionID string) ([]ListDispositionsBySellTransactionRow, error) {
	rows, err := q.db.Query(ctx, listDispositionsBySellTransaction, sellTransactionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListDispositionsBySellTransactionRow{}
	for rows.Next() {
		var i ListDispositionsBySellTransactionRow
		if err := rows.Scan(
			&i.ID,
			&i.LotID,
			&i.SellTransactionID,
			&i.DisposedDate,
			&i.QuantityMicros,
			&i.CostBasisMicros,
			&i.ProceedsMicros,
			&i.RealizedGainMicros,
			&i.HoldingPeriod,
			&i.CreatedAt,
			&i.AcquiredDate,
			&i.SecurityID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDispositionsByYear = `-- name: ListDispositionsByYear :many
select
    d.id, d.lot_id, d.sell_transaction_id, d.disposed_date, d.quantity_micros, d.cost_basis_micros, d.proceeds_micros, d.realized_gain_micros, d.holding_period, d.created_at,
    l.acquired_date,
    l.security_id,
    s.symbol,
    s.name as security_name
from monay.lot_dispositions d
join monay.lots l on l.id = d.lot_id
join monay.securities s on s.id = l.security_id
where
    extract(year from d.disposed_date) = $1
order by d.disposed_date asc
`

type ListDispositionsByYearRow struct {
	ID                 string             `json:"id"`
	LotID              string             `json:"lot_id"`
	SellTransactionID  string             `json:"sell_transaction_id"`
	DisposedDate       pgtype.Date        `json:"disposed_date"`
	QuantityMicros     int64              `json:"quantity_micros"`
	CostBasisMicros    int64              `json:"cost_basis_micros"`
	ProceedsMicros     int64              `json:"proceeds_micros"`
	RealizedGainMicros int64              `json:"realized_gain_micros"`
	HoldingPeriod      string             `json:"holding_period"`
	CreatedAt          pgtype.Timestamptz `json:"created_at"`
	AcquiredDate       pgtype.Date        `json:"acquired_date"`
	SecurityID         string             `json:"security_id"`
	Symbol             string             `json:"symbol"`
	SecurityName       pgtype.Text        `json:"security_name"`
}

func (q *Queries) ListDispositionsByYear(ctx context.Context, year pgtype.Date) ([]ListDispositionsByYearRow, error) {
	rows, err := q.db.Query(ctx, listDispositionsByYear, year)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListDispositionsByYearRow{}
	for rows.Next() {
		var i ListDispositionsByYearRow
		if err := rows.Scan(
			&i.ID,
			&i.LotID,
			&i.SellTransactionID,
			&i.DisposedDate,
			&i.QuantityMicros,
			&i.CostBasisMicros,
			&i.ProceedsMicros,
			&i.RealizedGainMicros,
			&i.HoldingPeriod,
			&i.CreatedAt,
			&i.AcquiredDate,
			&i.SecurityID,
			&i.Symbol,
			&i.SecurityName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listHoldingsByAccount = `-- name: ListHoldingsByAccount :many
select
    s.symbol,
    s.name as security_name,
    sum(l.remaining_micros)::bigint as quantity_micros,
    sum(
        case when l.remaining_micros > 0 
        then (l.cost_basis_micros::float / l.quantity_micros::float * l.remaining_micros::float)::bigint
        else 0 end
    )::bigint as cost_basis_micros,
    min(l.acquired_date) as earliest_acquired
from monay.lots l
join monay.securities s on s.id = l.security_id
where l.account_id = $1 and l.remaining_micros > 0
group by s.symbol, s.name
order by s.symbol
`

type ListHoldingsByAccountRow struct {
	Symbol           string      `json:"symbol"`
	SecurityName     pgtype.Text `json:"security_name"`
	QuantityMicros   int64       `json:"quantity_micros"`
	CostBasisMicros  int64       `json:"cost_basis_micros"`
	EarliestAcquired interface{} `json:"earliest_acquired"`
}

func (q *Queries) ListHoldingsByAccount(ctx context.Context, accountID string) ([]ListHoldingsByAccountRow, error) {
	rows, err := q.db.Query(ctx, listHoldingsByAccount, accountID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListHoldingsByAccountRow{}
	for rows.Next() {
		var i ListHoldingsByAccountRow
		if err := rows.Scan(
			&i.Symbol,
			&i.SecurityName,
			&i.QuantityMicros,
			&i.CostBasisMicros,
			&i.EarliestAcquired,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLotsByAccount = `-- name: ListLotsByAccount :many
select
    l.id, l.account_id, l.security_id, l.transaction_id, l.acquired_date, l.quantity_micros, l.remaining_micros, l.cost_basis_micros, l.created_at,
    s.symbol,
    s.name as security_name
from monay.lots l
join monay.securities s on s.id = l.security_id
where l.account_id = $1
order by l.acquired_date asc
`

type ListLotsByAccountRow struct {
	ID              string             `json:"id"`
	AccountID       string             `json:"account_id"`
	SecurityID      string             `json:"security_id"`
	TransactionID   string             `json:"transaction_id"`
	AcquiredDate    pgtype.Date        `json:"acquired_date"`
	QuantityMicros  int64              `json:"quantity_micros"`
	RemainingMicros int64              `json:"remaining_micros"`
	CostBasisMicros int64              `json:"cost_basis_micros"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
	Symbol          string             `json:"symbol"`
	SecurityName    pgtype.Text        `json:"security_name"`
}

func (q *Queries) ListLotsByAccount(ctx context.Context, accountID string) ([]ListLotsByAccountRow, error) {
	rows, err := q.db.Query(ctx, listLotsByAccount, accountID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListLotsByAccountRow{}
	for rows.Next() {
		var i ListLotsByAccountRow
		if err := rows.Scan(
			&i.ID,
			&i.AccountID,
			&i.SecurityID,
			&i.TransactionID,
			&i.AcquiredDate,
			&i.QuantityMicros,
			&i.RemainingMicros,
			&i.CostBasisMicros,
			&i.CreatedAt,
			&i.Symbol,
			&i.SecurityName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLotsByAccountAndSecurity = `-- name: ListLotsByAccountAndSecurity :many
select id, account_id, security_id, transaction_id, acquired_date, quantity_micros, remaining_micros, cost_basis_micros, created_at
from monay.lots
where
    account_id = $1
    and security_id = $2
    and remaining_micros > 0
order by acquired_date asc
`

type ListLotsByAccountAndSecurityParams struct {
	AccountID  string `json:"account_id"`
	SecurityID string `json:"security_id"`
}

func (q *Queries) ListLotsByAccountAndSecurity(ctx context.Context, arg ListLotsByAccountAndSecurityParams) ([]MonayLot, error) {
	rows, err := q.db.Query(ctx, listLotsByAccountAndSecurity, arg.AccountID, arg.SecurityID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []MonayLot{}
	for rows.Next() {
		var i MonayLot
		if err := rows.Scan(
			&i.ID,
			&i.AccountID,
			&i.SecurityID,
			&i.TransactionID,
			&i.AcquiredDate,
			&i.QuantityMicros,
			&i.RemainingMicros,
			&i.CostBasisMicros,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const sumRealizedGainsByYear = `-- name: SumRealizedGainsByYear :one
select
    coalesce(sum(case when holding_period = 'short_term' then realized_gain_micros else 0 end), 0)::bigint as short_term_gains,
    coalesce(sum(case when holding_period = 'long_term' then realized_gain_micros else 0 end), 0)::bigint as long_term_gains,
    coalesce(sum(realized_gain_micros), 0)::bigint as total_gains
from monay.lot_dispositions
where extract(year from disposed_date) = $1
`

type SumRealizedGainsByYearRow struct {
	ShortTermGains int64 `json:"short_term_gains"`
	LongTermGains  int64 `json:"long_term_gains"`
	TotalGains     int64 `json:"total_gains"`
}

func (q *Queries) SumRealizedGainsByYear(ctx context.Context, year pgtype.Date) (SumRealizedGainsByYearRow, error) {
	row := q.db.QueryRow(ctx, sumRealizedGainsByYear, year)
	var i SumRealizedGainsByYearRow
	err := row.Scan(&i.ShortTermGains, &i.LongTermGains, &i.TotalGains)
	return i, err
}

const sumRemainingBySymbol = `-- name: SumRemainingBySymbol :many
select
    s.symbol,
    s.id as security_id,
    coalesce(sum(l.remaining_micros), 0)::bigint as remaining_micros
from monay.securities s
left join monay.lots l on l.security_id = s.id and l.account_id = $1
where s.id in (
    select distinct security_id
    from monay.transactions
    where account_id = $1 and security_id is not null
)
group by s.symbol, s.id
`

type SumRemainingBySymbolRow struct {
	Symbol          string `json:"symbol"`
	SecurityID      string `json:"security_id"`
	RemainingMicros int64  `json:"remaining_micros"`
}

func (q *Queries) SumRemainingBySymbol(ctx context.Context, accountID string) ([]SumRemainingBySymbolRow, error) {
	rows, err := q.db.Query(ctx, sumRemainingBySymbol, accountID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SumRemainingBySymbolRow{}
	for rows.Next() {
		var i SumRemainingBySymbolRow
		if err := rows.Scan(&i.Symbol, &i.SecurityID, &i.RemainingMicros); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateLotRemaining = `-- name: UpdateLotRemaining :exec
update monay.lots
set remaining_micros = $1
where id = $2
`

type UpdateLotRemainingParams struct {
	RemainingMicros int64  `json:"remaining_micros"`
	ID              string `json:"id"`
}

func (q *Queries) UpdateLotRemaining(ctx context.Context, arg UpdateLotRemainingParams) error {
	_, err := q.db.Exec(ctx, updateLotRemaining, arg.RemainingMicros, arg.ID)
	return err
}
