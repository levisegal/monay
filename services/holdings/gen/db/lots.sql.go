// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: lots.sql

package db

import (
	"context"
	"database/sql"
)

const createLot = `-- name: CreateLot :one
insert into lots (
    id,
    account_id,
    security_id,
    transaction_id,
    acquired_date,
    quantity_micros,
    remaining_micros,
    cost_basis_micros
) values (
    ?1,
    ?2,
    ?3,
    ?4,
    ?5,
    ?6,
    ?7,
    ?8
)
returning id, account_id, security_id, transaction_id, acquired_date, quantity_micros, remaining_micros, cost_basis_micros, created_at
`

type CreateLotParams struct {
	ID              string `json:"id"`
	AccountID       string `json:"account_id"`
	SecurityID      string `json:"security_id"`
	TransactionID   string `json:"transaction_id"`
	AcquiredDate    string `json:"acquired_date"`
	QuantityMicros  int64  `json:"quantity_micros"`
	RemainingMicros int64  `json:"remaining_micros"`
	CostBasisMicros int64  `json:"cost_basis_micros"`
}

func (q *Queries) CreateLot(ctx context.Context, arg CreateLotParams) (Lot, error) {
	row := q.db.QueryRowContext(ctx, createLot,
		arg.ID,
		arg.AccountID,
		arg.SecurityID,
		arg.TransactionID,
		arg.AcquiredDate,
		arg.QuantityMicros,
		arg.RemainingMicros,
		arg.CostBasisMicros,
	)
	var i Lot
	err := row.Scan(
		&i.ID,
		&i.AccountID,
		&i.SecurityID,
		&i.TransactionID,
		&i.AcquiredDate,
		&i.QuantityMicros,
		&i.RemainingMicros,
		&i.CostBasisMicros,
		&i.CreatedAt,
	)
	return i, err
}

const createLotDisposition = `-- name: CreateLotDisposition :one
insert into lot_dispositions (
    id,
    lot_id,
    sell_transaction_id,
    disposed_date,
    quantity_micros,
    cost_basis_micros,
    proceeds_micros,
    realized_gain_micros,
    holding_period
) values (
    ?1,
    ?2,
    ?3,
    ?4,
    ?5,
    ?6,
    ?7,
    ?8,
    ?9
)
returning id, lot_id, sell_transaction_id, disposed_date, quantity_micros, cost_basis_micros, proceeds_micros, realized_gain_micros, holding_period, created_at
`

type CreateLotDispositionParams struct {
	ID                 string `json:"id"`
	LotID              string `json:"lot_id"`
	SellTransactionID  string `json:"sell_transaction_id"`
	DisposedDate       string `json:"disposed_date"`
	QuantityMicros     int64  `json:"quantity_micros"`
	CostBasisMicros    int64  `json:"cost_basis_micros"`
	ProceedsMicros     int64  `json:"proceeds_micros"`
	RealizedGainMicros int64  `json:"realized_gain_micros"`
	HoldingPeriod      string `json:"holding_period"`
}

func (q *Queries) CreateLotDisposition(ctx context.Context, arg CreateLotDispositionParams) (LotDisposition, error) {
	row := q.db.QueryRowContext(ctx, createLotDisposition,
		arg.ID,
		arg.LotID,
		arg.SellTransactionID,
		arg.DisposedDate,
		arg.QuantityMicros,
		arg.CostBasisMicros,
		arg.ProceedsMicros,
		arg.RealizedGainMicros,
		arg.HoldingPeriod,
	)
	var i LotDisposition
	err := row.Scan(
		&i.ID,
		&i.LotID,
		&i.SellTransactionID,
		&i.DisposedDate,
		&i.QuantityMicros,
		&i.CostBasisMicros,
		&i.ProceedsMicros,
		&i.RealizedGainMicros,
		&i.HoldingPeriod,
		&i.CreatedAt,
	)
	return i, err
}

const deleteLotsByAccount = `-- name: DeleteLotsByAccount :exec
delete from lot_dispositions
where lot_id in (select id from lots where account_id = ?1)
`

func (q *Queries) DeleteLotsByAccount(ctx context.Context, accountID string) error {
	_, err := q.db.ExecContext(ctx, deleteLotsByAccount, accountID)
	return err
}

const deleteLotsForAccount = `-- name: DeleteLotsForAccount :exec
delete from lots
where account_id = ?1
`

func (q *Queries) DeleteLotsForAccount(ctx context.Context, accountID string) error {
	_, err := q.db.ExecContext(ctx, deleteLotsForAccount, accountID)
	return err
}

const getLot = `-- name: GetLot :one
select id, account_id, security_id, transaction_id, acquired_date, quantity_micros, remaining_micros, cost_basis_micros, created_at
from lots
where id = ?1
`

func (q *Queries) GetLot(ctx context.Context, id string) (Lot, error) {
	row := q.db.QueryRowContext(ctx, getLot, id)
	var i Lot
	err := row.Scan(
		&i.ID,
		&i.AccountID,
		&i.SecurityID,
		&i.TransactionID,
		&i.AcquiredDate,
		&i.QuantityMicros,
		&i.RemainingMicros,
		&i.CostBasisMicros,
		&i.CreatedAt,
	)
	return i, err
}

const listAllHoldings = `-- name: ListAllHoldings :many
select
    a.institution_name as broker,
    a.name as account_name,
    s.symbol,
    s.name as security_name,
    sum(l.remaining_micros) as quantity_micros,
    sum(
        case when l.remaining_micros > 0
        then cast(cast(l.cost_basis_micros as real) / cast(l.quantity_micros as real) * cast(l.remaining_micros as real) as integer)
        else 0 end
    ) as cost_basis_micros,
    min(l.acquired_date) as earliest_acquired
from lots l
join securities s on s.id = l.security_id
join accounts a on a.id = l.account_id
where l.remaining_micros > 0
group by a.institution_name, a.name, s.symbol, s.name
order by cost_basis_micros desc
`

type ListAllHoldingsRow struct {
	Broker           string          `json:"broker"`
	AccountName      string          `json:"account_name"`
	Symbol           string          `json:"symbol"`
	SecurityName     sql.NullString  `json:"security_name"`
	QuantityMicros   sql.NullFloat64 `json:"quantity_micros"`
	CostBasisMicros  sql.NullFloat64 `json:"cost_basis_micros"`
	EarliestAcquired interface{}     `json:"earliest_acquired"`
}

func (q *Queries) ListAllHoldings(ctx context.Context) ([]ListAllHoldingsRow, error) {
	rows, err := q.db.QueryContext(ctx, listAllHoldings)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListAllHoldingsRow{}
	for rows.Next() {
		var i ListAllHoldingsRow
		if err := rows.Scan(
			&i.Broker,
			&i.AccountName,
			&i.Symbol,
			&i.SecurityName,
			&i.QuantityMicros,
			&i.CostBasisMicros,
			&i.EarliestAcquired,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDispositionsBySellTransaction = `-- name: ListDispositionsBySellTransaction :many
select
    d.id, d.lot_id, d.sell_transaction_id, d.disposed_date, d.quantity_micros, d.cost_basis_micros, d.proceeds_micros, d.realized_gain_micros, d.holding_period, d.created_at,
    l.acquired_date,
    l.security_id
from lot_dispositions d
join lots l on l.id = d.lot_id
where d.sell_transaction_id = ?1
`

type ListDispositionsBySellTransactionRow struct {
	ID                 string `json:"id"`
	LotID              string `json:"lot_id"`
	SellTransactionID  string `json:"sell_transaction_id"`
	DisposedDate       string `json:"disposed_date"`
	QuantityMicros     int64  `json:"quantity_micros"`
	CostBasisMicros    int64  `json:"cost_basis_micros"`
	ProceedsMicros     int64  `json:"proceeds_micros"`
	RealizedGainMicros int64  `json:"realized_gain_micros"`
	HoldingPeriod      string `json:"holding_period"`
	CreatedAt          string `json:"created_at"`
	AcquiredDate       string `json:"acquired_date"`
	SecurityID         string `json:"security_id"`
}

func (q *Queries) ListDispositionsBySellTransaction(ctx context.Context, sellTransactionID string) ([]ListDispositionsBySellTransactionRow, error) {
	rows, err := q.db.QueryContext(ctx, listDispositionsBySellTransaction, sellTransactionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListDispositionsBySellTransactionRow{}
	for rows.Next() {
		var i ListDispositionsBySellTransactionRow
		if err := rows.Scan(
			&i.ID,
			&i.LotID,
			&i.SellTransactionID,
			&i.DisposedDate,
			&i.QuantityMicros,
			&i.CostBasisMicros,
			&i.ProceedsMicros,
			&i.RealizedGainMicros,
			&i.HoldingPeriod,
			&i.CreatedAt,
			&i.AcquiredDate,
			&i.SecurityID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDispositionsByYear = `-- name: ListDispositionsByYear :many
select
    d.id, d.lot_id, d.sell_transaction_id, d.disposed_date, d.quantity_micros, d.cost_basis_micros, d.proceeds_micros, d.realized_gain_micros, d.holding_period, d.created_at,
    l.acquired_date,
    l.security_id,
    s.symbol,
    s.name as security_name
from lot_dispositions d
join lots l on l.id = d.lot_id
join securities s on s.id = l.security_id
where
    strftime('%Y', d.disposed_date) = ?1
order by d.disposed_date asc
`

type ListDispositionsByYearRow struct {
	ID                 string         `json:"id"`
	LotID              string         `json:"lot_id"`
	SellTransactionID  string         `json:"sell_transaction_id"`
	DisposedDate       string         `json:"disposed_date"`
	QuantityMicros     int64          `json:"quantity_micros"`
	CostBasisMicros    int64          `json:"cost_basis_micros"`
	ProceedsMicros     int64          `json:"proceeds_micros"`
	RealizedGainMicros int64          `json:"realized_gain_micros"`
	HoldingPeriod      string         `json:"holding_period"`
	CreatedAt          string         `json:"created_at"`
	AcquiredDate       string         `json:"acquired_date"`
	SecurityID         string         `json:"security_id"`
	Symbol             string         `json:"symbol"`
	SecurityName       sql.NullString `json:"security_name"`
}

func (q *Queries) ListDispositionsByYear(ctx context.Context, year string) ([]ListDispositionsByYearRow, error) {
	rows, err := q.db.QueryContext(ctx, listDispositionsByYear, year)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListDispositionsByYearRow{}
	for rows.Next() {
		var i ListDispositionsByYearRow
		if err := rows.Scan(
			&i.ID,
			&i.LotID,
			&i.SellTransactionID,
			&i.DisposedDate,
			&i.QuantityMicros,
			&i.CostBasisMicros,
			&i.ProceedsMicros,
			&i.RealizedGainMicros,
			&i.HoldingPeriod,
			&i.CreatedAt,
			&i.AcquiredDate,
			&i.SecurityID,
			&i.Symbol,
			&i.SecurityName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listHoldingsByAccount = `-- name: ListHoldingsByAccount :many
select
    s.symbol,
    s.name as security_name,
    sum(l.remaining_micros) as quantity_micros,
    sum(
        case when l.remaining_micros > 0
        then cast(cast(l.cost_basis_micros as real) / cast(l.quantity_micros as real) * cast(l.remaining_micros as real) as integer)
        else 0 end
    ) as cost_basis_micros,
    min(l.acquired_date) as earliest_acquired
from lots l
join securities s on s.id = l.security_id
where l.account_id = ?1 and l.remaining_micros > 0
group by s.symbol, s.name
order by s.symbol
`

type ListHoldingsByAccountRow struct {
	Symbol           string          `json:"symbol"`
	SecurityName     sql.NullString  `json:"security_name"`
	QuantityMicros   sql.NullFloat64 `json:"quantity_micros"`
	CostBasisMicros  sql.NullFloat64 `json:"cost_basis_micros"`
	EarliestAcquired interface{}     `json:"earliest_acquired"`
}

func (q *Queries) ListHoldingsByAccount(ctx context.Context, accountID string) ([]ListHoldingsByAccountRow, error) {
	rows, err := q.db.QueryContext(ctx, listHoldingsByAccount, accountID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListHoldingsByAccountRow{}
	for rows.Next() {
		var i ListHoldingsByAccountRow
		if err := rows.Scan(
			&i.Symbol,
			&i.SecurityName,
			&i.QuantityMicros,
			&i.CostBasisMicros,
			&i.EarliestAcquired,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLotsByAccount = `-- name: ListLotsByAccount :many
select
    l.id, l.account_id, l.security_id, l.transaction_id, l.acquired_date, l.quantity_micros, l.remaining_micros, l.cost_basis_micros, l.created_at,
    s.symbol,
    s.name as security_name
from lots l
join securities s on s.id = l.security_id
where l.account_id = ?1
order by l.acquired_date asc
`

type ListLotsByAccountRow struct {
	ID              string         `json:"id"`
	AccountID       string         `json:"account_id"`
	SecurityID      string         `json:"security_id"`
	TransactionID   string         `json:"transaction_id"`
	AcquiredDate    string         `json:"acquired_date"`
	QuantityMicros  int64          `json:"quantity_micros"`
	RemainingMicros int64          `json:"remaining_micros"`
	CostBasisMicros int64          `json:"cost_basis_micros"`
	CreatedAt       string         `json:"created_at"`
	Symbol          string         `json:"symbol"`
	SecurityName    sql.NullString `json:"security_name"`
}

func (q *Queries) ListLotsByAccount(ctx context.Context, accountID string) ([]ListLotsByAccountRow, error) {
	rows, err := q.db.QueryContext(ctx, listLotsByAccount, accountID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListLotsByAccountRow{}
	for rows.Next() {
		var i ListLotsByAccountRow
		if err := rows.Scan(
			&i.ID,
			&i.AccountID,
			&i.SecurityID,
			&i.TransactionID,
			&i.AcquiredDate,
			&i.QuantityMicros,
			&i.RemainingMicros,
			&i.CostBasisMicros,
			&i.CreatedAt,
			&i.Symbol,
			&i.SecurityName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLotsByAccountAndSecurity = `-- name: ListLotsByAccountAndSecurity :many
select id, account_id, security_id, transaction_id, acquired_date, quantity_micros, remaining_micros, cost_basis_micros, created_at
from lots
where
    account_id = ?1
    and security_id = ?2
    and remaining_micros > 0
order by acquired_date asc
`

type ListLotsByAccountAndSecurityParams struct {
	AccountID  string `json:"account_id"`
	SecurityID string `json:"security_id"`
}

func (q *Queries) ListLotsByAccountAndSecurity(ctx context.Context, arg ListLotsByAccountAndSecurityParams) ([]Lot, error) {
	rows, err := q.db.QueryContext(ctx, listLotsByAccountAndSecurity, arg.AccountID, arg.SecurityID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Lot{}
	for rows.Next() {
		var i Lot
		if err := rows.Scan(
			&i.ID,
			&i.AccountID,
			&i.SecurityID,
			&i.TransactionID,
			&i.AcquiredDate,
			&i.QuantityMicros,
			&i.RemainingMicros,
			&i.CostBasisMicros,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPositions = `-- name: ListPositions :many
select
    s.symbol,
    s.name as security_name,
    count(distinct a.id) as account_count,
    sum(l.remaining_micros) as quantity_micros,
    sum(
        case when l.remaining_micros > 0
        then cast(cast(l.cost_basis_micros as real) / cast(l.quantity_micros as real) * cast(l.remaining_micros as real) as integer)
        else 0 end
    ) as cost_basis_micros,
    min(l.acquired_date) as earliest_acquired
from lots l
join securities s on s.id = l.security_id
join accounts a on a.id = l.account_id
where l.remaining_micros > 0
group by s.symbol, s.name
order by cost_basis_micros desc
`

type ListPositionsRow struct {
	Symbol           string          `json:"symbol"`
	SecurityName     sql.NullString  `json:"security_name"`
	AccountCount     int64           `json:"account_count"`
	QuantityMicros   sql.NullFloat64 `json:"quantity_micros"`
	CostBasisMicros  sql.NullFloat64 `json:"cost_basis_micros"`
	EarliestAcquired interface{}     `json:"earliest_acquired"`
}

func (q *Queries) ListPositions(ctx context.Context) ([]ListPositionsRow, error) {
	rows, err := q.db.QueryContext(ctx, listPositions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListPositionsRow{}
	for rows.Next() {
		var i ListPositionsRow
		if err := rows.Scan(
			&i.Symbol,
			&i.SecurityName,
			&i.AccountCount,
			&i.QuantityMicros,
			&i.CostBasisMicros,
			&i.EarliestAcquired,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const sumRealizedGainsByYear = `-- name: SumRealizedGainsByYear :one
select
    coalesce(sum(case when holding_period = 'short_term' then realized_gain_micros else 0 end), 0) as short_term_gains,
    coalesce(sum(case when holding_period = 'long_term' then realized_gain_micros else 0 end), 0) as long_term_gains,
    coalesce(sum(realized_gain_micros), 0) as total_gains
from lot_dispositions
where strftime('%Y', disposed_date) = ?1
`

type SumRealizedGainsByYearRow struct {
	ShortTermGains interface{} `json:"short_term_gains"`
	LongTermGains  interface{} `json:"long_term_gains"`
	TotalGains     interface{} `json:"total_gains"`
}

func (q *Queries) SumRealizedGainsByYear(ctx context.Context, year string) (SumRealizedGainsByYearRow, error) {
	row := q.db.QueryRowContext(ctx, sumRealizedGainsByYear, year)
	var i SumRealizedGainsByYearRow
	err := row.Scan(&i.ShortTermGains, &i.LongTermGains, &i.TotalGains)
	return i, err
}

const sumRemainingBySymbol = `-- name: SumRemainingBySymbol :many
select
    s.symbol,
    s.id as security_id,
    coalesce(sum(l.remaining_micros), 0) as remaining_micros
from securities s
left join lots l on l.security_id = s.id and l.account_id = ?1
where s.id in (
    select distinct security_id
    from transactions
    where account_id = ?1 and security_id is not null
)
group by s.symbol, s.id
`

type SumRemainingBySymbolRow struct {
	Symbol          string      `json:"symbol"`
	SecurityID      string      `json:"security_id"`
	RemainingMicros interface{} `json:"remaining_micros"`
}

func (q *Queries) SumRemainingBySymbol(ctx context.Context, accountID string) ([]SumRemainingBySymbolRow, error) {
	rows, err := q.db.QueryContext(ctx, sumRemainingBySymbol, accountID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SumRemainingBySymbolRow{}
	for rows.Next() {
		var i SumRemainingBySymbolRow
		if err := rows.Scan(&i.Symbol, &i.SecurityID, &i.RemainingMicros); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateLotRemaining = `-- name: UpdateLotRemaining :exec
update lots
set remaining_micros = ?1
where id = ?2
`

type UpdateLotRemainingParams struct {
	RemainingMicros int64  `json:"remaining_micros"`
	ID              string `json:"id"`
}

func (q *Queries) UpdateLotRemaining(ctx context.Context, arg UpdateLotRemainingParams) error {
	_, err := q.db.ExecContext(ctx, updateLotRemaining, arg.RemainingMicros, arg.ID)
	return err
}
