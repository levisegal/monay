// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: transactions.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createTransaction = `-- name: CreateTransaction :exec
insert into monay.transactions (
    id,
    account_id,
    security_id,
    transaction_type,
    transaction_date,
    quantity_micros,
    price_micros,
    amount_micros,
    fees_micros,
    description
) values (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8,
    $9,
    $10
)
on conflict do nothing
`

type CreateTransactionParams struct {
	ID              string      `json:"id"`
	AccountID       string      `json:"account_id"`
	SecurityID      pgtype.Text `json:"security_id"`
	TransactionType string      `json:"transaction_type"`
	TransactionDate pgtype.Date `json:"transaction_date"`
	QuantityMicros  pgtype.Int8 `json:"quantity_micros"`
	PriceMicros     pgtype.Int8 `json:"price_micros"`
	AmountMicros    int64       `json:"amount_micros"`
	FeesMicros      pgtype.Int8 `json:"fees_micros"`
	Description     pgtype.Text `json:"description"`
}

func (q *Queries) CreateTransaction(ctx context.Context, arg CreateTransactionParams) error {
	_, err := q.db.Exec(ctx, createTransaction,
		arg.ID,
		arg.AccountID,
		arg.SecurityID,
		arg.TransactionType,
		arg.TransactionDate,
		arg.QuantityMicros,
		arg.PriceMicros,
		arg.AmountMicros,
		arg.FeesMicros,
		arg.Description,
	)
	return err
}

const deleteTransaction = `-- name: DeleteTransaction :exec
delete from monay.transactions
where id = $1
`

func (q *Queries) DeleteTransaction(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, deleteTransaction, id)
	return err
}

const deleteTransactionsByAccount = `-- name: DeleteTransactionsByAccount :exec
delete from monay.transactions
where account_id = $1
`

func (q *Queries) DeleteTransactionsByAccount(ctx context.Context, accountID string) error {
	_, err := q.db.Exec(ctx, deleteTransactionsByAccount, accountID)
	return err
}

const getTransaction = `-- name: GetTransaction :one
select id, account_id, security_id, transaction_type, transaction_date, quantity_micros, price_micros, amount_micros, fees_micros, description, created_at
from monay.transactions
where id = $1
`

func (q *Queries) GetTransaction(ctx context.Context, id string) (MonayTransaction, error) {
	row := q.db.QueryRow(ctx, getTransaction, id)
	var i MonayTransaction
	err := row.Scan(
		&i.ID,
		&i.AccountID,
		&i.SecurityID,
		&i.TransactionType,
		&i.TransactionDate,
		&i.QuantityMicros,
		&i.PriceMicros,
		&i.AmountMicros,
		&i.FeesMicros,
		&i.Description,
		&i.CreatedAt,
	)
	return i, err
}

const listTransactionsByAccount = `-- name: ListTransactionsByAccount :many
select
    t.id, t.account_id, t.security_id, t.transaction_type, t.transaction_date, t.quantity_micros, t.price_micros, t.amount_micros, t.fees_micros, t.description, t.created_at,
    s.symbol,
    s.name as security_name
from monay.transactions t
left join monay.securities s on s.id = t.security_id
where t.account_id = $1
order by t.transaction_date desc, t.created_at desc
`

type ListTransactionsByAccountRow struct {
	ID              string             `json:"id"`
	AccountID       string             `json:"account_id"`
	SecurityID      pgtype.Text        `json:"security_id"`
	TransactionType string             `json:"transaction_type"`
	TransactionDate pgtype.Date        `json:"transaction_date"`
	QuantityMicros  pgtype.Int8        `json:"quantity_micros"`
	PriceMicros     pgtype.Int8        `json:"price_micros"`
	AmountMicros    int64              `json:"amount_micros"`
	FeesMicros      pgtype.Int8        `json:"fees_micros"`
	Description     pgtype.Text        `json:"description"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
	Symbol          pgtype.Text        `json:"symbol"`
	SecurityName    pgtype.Text        `json:"security_name"`
}

func (q *Queries) ListTransactionsByAccount(ctx context.Context, accountID string) ([]ListTransactionsByAccountRow, error) {
	rows, err := q.db.Query(ctx, listTransactionsByAccount, accountID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListTransactionsByAccountRow{}
	for rows.Next() {
		var i ListTransactionsByAccountRow
		if err := rows.Scan(
			&i.ID,
			&i.AccountID,
			&i.SecurityID,
			&i.TransactionType,
			&i.TransactionDate,
			&i.QuantityMicros,
			&i.PriceMicros,
			&i.AmountMicros,
			&i.FeesMicros,
			&i.Description,
			&i.CreatedAt,
			&i.Symbol,
			&i.SecurityName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTransactionsByAccountAndDateRange = `-- name: ListTransactionsByAccountAndDateRange :many
select
    t.id, t.account_id, t.security_id, t.transaction_type, t.transaction_date, t.quantity_micros, t.price_micros, t.amount_micros, t.fees_micros, t.description, t.created_at,
    s.symbol,
    s.name as security_name
from monay.transactions t
left join monay.securities s on s.id = t.security_id
where
    t.account_id = $1
    and t.transaction_date >= $2
    and t.transaction_date <= $3
order by t.transaction_date desc, t.created_at desc
`

type ListTransactionsByAccountAndDateRangeParams struct {
	AccountID string      `json:"account_id"`
	StartDate pgtype.Date `json:"start_date"`
	EndDate   pgtype.Date `json:"end_date"`
}

type ListTransactionsByAccountAndDateRangeRow struct {
	ID              string             `json:"id"`
	AccountID       string             `json:"account_id"`
	SecurityID      pgtype.Text        `json:"security_id"`
	TransactionType string             `json:"transaction_type"`
	TransactionDate pgtype.Date        `json:"transaction_date"`
	QuantityMicros  pgtype.Int8        `json:"quantity_micros"`
	PriceMicros     pgtype.Int8        `json:"price_micros"`
	AmountMicros    int64              `json:"amount_micros"`
	FeesMicros      pgtype.Int8        `json:"fees_micros"`
	Description     pgtype.Text        `json:"description"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
	Symbol          pgtype.Text        `json:"symbol"`
	SecurityName    pgtype.Text        `json:"security_name"`
}

func (q *Queries) ListTransactionsByAccountAndDateRange(ctx context.Context, arg ListTransactionsByAccountAndDateRangeParams) ([]ListTransactionsByAccountAndDateRangeRow, error) {
	rows, err := q.db.Query(ctx, listTransactionsByAccountAndDateRange, arg.AccountID, arg.StartDate, arg.EndDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListTransactionsByAccountAndDateRangeRow{}
	for rows.Next() {
		var i ListTransactionsByAccountAndDateRangeRow
		if err := rows.Scan(
			&i.ID,
			&i.AccountID,
			&i.SecurityID,
			&i.TransactionType,
			&i.TransactionDate,
			&i.QuantityMicros,
			&i.PriceMicros,
			&i.AmountMicros,
			&i.FeesMicros,
			&i.Description,
			&i.CreatedAt,
			&i.Symbol,
			&i.SecurityName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
