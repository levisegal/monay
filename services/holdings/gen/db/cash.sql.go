// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: cash.sql

package db

import (
	"context"
	"database/sql"
)

const createCashTransaction = `-- name: CreateCashTransaction :exec
insert into cash_transactions (
    id,
    account_id,
    transaction_id,
    transaction_date,
    cash_type,
    amount_micros,
    security_id,
    description
) values (
    ?1,
    ?2,
    ?3,
    ?4,
    ?5,
    ?6,
    ?7,
    ?8
)
on conflict do nothing
`

type CreateCashTransactionParams struct {
	ID              string         `json:"id"`
	AccountID       string         `json:"account_id"`
	TransactionID   sql.NullString `json:"transaction_id"`
	TransactionDate string         `json:"transaction_date"`
	CashType        string         `json:"cash_type"`
	AmountMicros    int64          `json:"amount_micros"`
	SecurityID      sql.NullString `json:"security_id"`
	Description     sql.NullString `json:"description"`
}

func (q *Queries) CreateCashTransaction(ctx context.Context, arg CreateCashTransactionParams) error {
	_, err := q.db.ExecContext(ctx, createCashTransaction,
		arg.ID,
		arg.AccountID,
		arg.TransactionID,
		arg.TransactionDate,
		arg.CashType,
		arg.AmountMicros,
		arg.SecurityID,
		arg.Description,
	)
	return err
}

const deleteCashTransactionsByAccount = `-- name: DeleteCashTransactionsByAccount :exec
delete from cash_transactions
where account_id = ?1
`

func (q *Queries) DeleteCashTransactionsByAccount(ctx context.Context, accountID string) error {
	_, err := q.db.ExecContext(ctx, deleteCashTransactionsByAccount, accountID)
	return err
}

const deleteCashTransactionsByTransactionId = `-- name: DeleteCashTransactionsByTransactionId :exec
delete from cash_transactions
where transaction_id = ?1
`

func (q *Queries) DeleteCashTransactionsByTransactionId(ctx context.Context, transactionID sql.NullString) error {
	_, err := q.db.ExecContext(ctx, deleteCashTransactionsByTransactionId, transactionID)
	return err
}

const deleteNonOpeningCashTransactionsByAccount = `-- name: DeleteNonOpeningCashTransactionsByAccount :exec
delete from cash_transactions
where
    account_id = ?1
    and cash_type != 'opening'
`

func (q *Queries) DeleteNonOpeningCashTransactionsByAccount(ctx context.Context, accountID string) error {
	_, err := q.db.ExecContext(ctx, deleteNonOpeningCashTransactionsByAccount, accountID)
	return err
}

const getCashBalance = `-- name: GetCashBalance :one
select coalesce(sum(amount_micros), 0) as balance_micros
from cash_transactions
where account_id = ?1
`

func (q *Queries) GetCashBalance(ctx context.Context, accountID string) (interface{}, error) {
	row := q.db.QueryRowContext(ctx, getCashBalance, accountID)
	var balance_micros interface{}
	err := row.Scan(&balance_micros)
	return balance_micros, err
}

const getCashBalanceAsOfDate = `-- name: GetCashBalanceAsOfDate :one
select coalesce(sum(amount_micros), 0) as balance_micros
from cash_transactions
where
    account_id = ?1
    and transaction_date <= ?2
`

type GetCashBalanceAsOfDateParams struct {
	AccountID string `json:"account_id"`
	AsOfDate  string `json:"as_of_date"`
}

func (q *Queries) GetCashBalanceAsOfDate(ctx context.Context, arg GetCashBalanceAsOfDateParams) (interface{}, error) {
	row := q.db.QueryRowContext(ctx, getCashBalanceAsOfDate, arg.AccountID, arg.AsOfDate)
	var balance_micros interface{}
	err := row.Scan(&balance_micros)
	return balance_micros, err
}

const getOpeningCashBalance = `-- name: GetOpeningCashBalance :one
select id, account_id, transaction_id, transaction_date, cash_type, amount_micros, security_id, description, created_at
from cash_transactions
where
    account_id = ?1
    and cash_type = 'opening'
limit 1
`

func (q *Queries) GetOpeningCashBalance(ctx context.Context, accountID string) (CashTransaction, error) {
	row := q.db.QueryRowContext(ctx, getOpeningCashBalance, accountID)
	var i CashTransaction
	err := row.Scan(
		&i.ID,
		&i.AccountID,
		&i.TransactionID,
		&i.TransactionDate,
		&i.CashType,
		&i.AmountMicros,
		&i.SecurityID,
		&i.Description,
		&i.CreatedAt,
	)
	return i, err
}

const listCashTransactions = `-- name: ListCashTransactions :many
select
    ct.id, ct.account_id, ct.transaction_id, ct.transaction_date, ct.cash_type, ct.amount_micros, ct.security_id, ct.description, ct.created_at,
    s.symbol,
    s.name as security_name
from cash_transactions ct
left join securities s on s.id = ct.security_id
where ct.account_id = ?1
order by ct.transaction_date desc, ct.created_at desc
`

type ListCashTransactionsRow struct {
	ID              string         `json:"id"`
	AccountID       string         `json:"account_id"`
	TransactionID   sql.NullString `json:"transaction_id"`
	TransactionDate string         `json:"transaction_date"`
	CashType        string         `json:"cash_type"`
	AmountMicros    int64          `json:"amount_micros"`
	SecurityID      sql.NullString `json:"security_id"`
	Description     sql.NullString `json:"description"`
	CreatedAt       string         `json:"created_at"`
	Symbol          sql.NullString `json:"symbol"`
	SecurityName    sql.NullString `json:"security_name"`
}

func (q *Queries) ListCashTransactions(ctx context.Context, accountID string) ([]ListCashTransactionsRow, error) {
	rows, err := q.db.QueryContext(ctx, listCashTransactions, accountID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListCashTransactionsRow{}
	for rows.Next() {
		var i ListCashTransactionsRow
		if err := rows.Scan(
			&i.ID,
			&i.AccountID,
			&i.TransactionID,
			&i.TransactionDate,
			&i.CashType,
			&i.AmountMicros,
			&i.SecurityID,
			&i.Description,
			&i.CreatedAt,
			&i.Symbol,
			&i.SecurityName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCashTransactionsByDateRange = `-- name: ListCashTransactionsByDateRange :many
select
    ct.id, ct.account_id, ct.transaction_id, ct.transaction_date, ct.cash_type, ct.amount_micros, ct.security_id, ct.description, ct.created_at,
    s.symbol,
    s.name as security_name
from cash_transactions ct
left join securities s on s.id = ct.security_id
where
    ct.account_id = ?1
    and ct.transaction_date >= ?2
    and ct.transaction_date <= ?3
order by ct.transaction_date desc, ct.created_at desc
`

type ListCashTransactionsByDateRangeParams struct {
	AccountID string `json:"account_id"`
	StartDate string `json:"start_date"`
	EndDate   string `json:"end_date"`
}

type ListCashTransactionsByDateRangeRow struct {
	ID              string         `json:"id"`
	AccountID       string         `json:"account_id"`
	TransactionID   sql.NullString `json:"transaction_id"`
	TransactionDate string         `json:"transaction_date"`
	CashType        string         `json:"cash_type"`
	AmountMicros    int64          `json:"amount_micros"`
	SecurityID      sql.NullString `json:"security_id"`
	Description     sql.NullString `json:"description"`
	CreatedAt       string         `json:"created_at"`
	Symbol          sql.NullString `json:"symbol"`
	SecurityName    sql.NullString `json:"security_name"`
}

func (q *Queries) ListCashTransactionsByDateRange(ctx context.Context, arg ListCashTransactionsByDateRangeParams) ([]ListCashTransactionsByDateRangeRow, error) {
	rows, err := q.db.QueryContext(ctx, listCashTransactionsByDateRange, arg.AccountID, arg.StartDate, arg.EndDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListCashTransactionsByDateRangeRow{}
	for rows.Next() {
		var i ListCashTransactionsByDateRangeRow
		if err := rows.Scan(
			&i.ID,
			&i.AccountID,
			&i.TransactionID,
			&i.TransactionDate,
			&i.CashType,
			&i.AmountMicros,
			&i.SecurityID,
			&i.Description,
			&i.CreatedAt,
			&i.Symbol,
			&i.SecurityName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
