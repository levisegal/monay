// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: cash.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createCashTransaction = `-- name: CreateCashTransaction :exec
insert into monay.cash_transactions (
    id,
    account_id,
    transaction_id,
    transaction_date,
    cash_type,
    amount_micros,
    security_id,
    description
) values (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8
)
on conflict do nothing
`

type CreateCashTransactionParams struct {
	ID              string      `json:"id"`
	AccountID       string      `json:"account_id"`
	TransactionID   pgtype.Text `json:"transaction_id"`
	TransactionDate pgtype.Date `json:"transaction_date"`
	CashType        string      `json:"cash_type"`
	AmountMicros    int64       `json:"amount_micros"`
	SecurityID      pgtype.Text `json:"security_id"`
	Description     pgtype.Text `json:"description"`
}

func (q *Queries) CreateCashTransaction(ctx context.Context, arg CreateCashTransactionParams) error {
	_, err := q.db.Exec(ctx, createCashTransaction,
		arg.ID,
		arg.AccountID,
		arg.TransactionID,
		arg.TransactionDate,
		arg.CashType,
		arg.AmountMicros,
		arg.SecurityID,
		arg.Description,
	)
	return err
}

const deleteCashTransactionsByAccount = `-- name: DeleteCashTransactionsByAccount :exec
delete from monay.cash_transactions
where account_id = $1
`

func (q *Queries) DeleteCashTransactionsByAccount(ctx context.Context, accountID string) error {
	_, err := q.db.Exec(ctx, deleteCashTransactionsByAccount, accountID)
	return err
}

const deleteCashTransactionsByTransactionId = `-- name: DeleteCashTransactionsByTransactionId :exec
delete from monay.cash_transactions
where transaction_id = $1
`

func (q *Queries) DeleteCashTransactionsByTransactionId(ctx context.Context, transactionID pgtype.Text) error {
	_, err := q.db.Exec(ctx, deleteCashTransactionsByTransactionId, transactionID)
	return err
}

const deleteNonOpeningCashTransactionsByAccount = `-- name: DeleteNonOpeningCashTransactionsByAccount :exec
delete from monay.cash_transactions
where
    account_id = $1
    and cash_type != 'opening'
`

func (q *Queries) DeleteNonOpeningCashTransactionsByAccount(ctx context.Context, accountID string) error {
	_, err := q.db.Exec(ctx, deleteNonOpeningCashTransactionsByAccount, accountID)
	return err
}

const getCashBalance = `-- name: GetCashBalance :one
select coalesce(sum(amount_micros), 0)::bigint as balance_micros
from monay.cash_transactions
where account_id = $1
`

func (q *Queries) GetCashBalance(ctx context.Context, accountID string) (int64, error) {
	row := q.db.QueryRow(ctx, getCashBalance, accountID)
	var balance_micros int64
	err := row.Scan(&balance_micros)
	return balance_micros, err
}

const getCashBalanceAsOfDate = `-- name: GetCashBalanceAsOfDate :one
select coalesce(sum(amount_micros), 0)::bigint as balance_micros
from monay.cash_transactions
where
    account_id = $1
    and transaction_date <= $2
`

type GetCashBalanceAsOfDateParams struct {
	AccountID string      `json:"account_id"`
	AsOfDate  pgtype.Date `json:"as_of_date"`
}

func (q *Queries) GetCashBalanceAsOfDate(ctx context.Context, arg GetCashBalanceAsOfDateParams) (int64, error) {
	row := q.db.QueryRow(ctx, getCashBalanceAsOfDate, arg.AccountID, arg.AsOfDate)
	var balance_micros int64
	err := row.Scan(&balance_micros)
	return balance_micros, err
}

const getOpeningCashBalance = `-- name: GetOpeningCashBalance :one
select id, account_id, transaction_id, transaction_date, cash_type, amount_micros, security_id, description, created_at
from monay.cash_transactions
where
    account_id = $1
    and cash_type = 'opening'
limit 1
`

func (q *Queries) GetOpeningCashBalance(ctx context.Context, accountID string) (MonayCashTransaction, error) {
	row := q.db.QueryRow(ctx, getOpeningCashBalance, accountID)
	var i MonayCashTransaction
	err := row.Scan(
		&i.ID,
		&i.AccountID,
		&i.TransactionID,
		&i.TransactionDate,
		&i.CashType,
		&i.AmountMicros,
		&i.SecurityID,
		&i.Description,
		&i.CreatedAt,
	)
	return i, err
}

const listCashTransactions = `-- name: ListCashTransactions :many
select
    ct.id, ct.account_id, ct.transaction_id, ct.transaction_date, ct.cash_type, ct.amount_micros, ct.security_id, ct.description, ct.created_at,
    s.symbol,
    s.name as security_name
from monay.cash_transactions ct
left join monay.securities s on s.id = ct.security_id
where ct.account_id = $1
order by ct.transaction_date desc, ct.created_at desc
`

type ListCashTransactionsRow struct {
	ID              string             `json:"id"`
	AccountID       string             `json:"account_id"`
	TransactionID   pgtype.Text        `json:"transaction_id"`
	TransactionDate pgtype.Date        `json:"transaction_date"`
	CashType        string             `json:"cash_type"`
	AmountMicros    int64              `json:"amount_micros"`
	SecurityID      pgtype.Text        `json:"security_id"`
	Description     pgtype.Text        `json:"description"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
	Symbol          pgtype.Text        `json:"symbol"`
	SecurityName    pgtype.Text        `json:"security_name"`
}

func (q *Queries) ListCashTransactions(ctx context.Context, accountID string) ([]ListCashTransactionsRow, error) {
	rows, err := q.db.Query(ctx, listCashTransactions, accountID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListCashTransactionsRow{}
	for rows.Next() {
		var i ListCashTransactionsRow
		if err := rows.Scan(
			&i.ID,
			&i.AccountID,
			&i.TransactionID,
			&i.TransactionDate,
			&i.CashType,
			&i.AmountMicros,
			&i.SecurityID,
			&i.Description,
			&i.CreatedAt,
			&i.Symbol,
			&i.SecurityName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCashTransactionsByDateRange = `-- name: ListCashTransactionsByDateRange :many
select
    ct.id, ct.account_id, ct.transaction_id, ct.transaction_date, ct.cash_type, ct.amount_micros, ct.security_id, ct.description, ct.created_at,
    s.symbol,
    s.name as security_name
from monay.cash_transactions ct
left join monay.securities s on s.id = ct.security_id
where
    ct.account_id = $1
    and ct.transaction_date >= $2
    and ct.transaction_date <= $3
order by ct.transaction_date desc, ct.created_at desc
`

type ListCashTransactionsByDateRangeParams struct {
	AccountID string      `json:"account_id"`
	StartDate pgtype.Date `json:"start_date"`
	EndDate   pgtype.Date `json:"end_date"`
}

type ListCashTransactionsByDateRangeRow struct {
	ID              string             `json:"id"`
	AccountID       string             `json:"account_id"`
	TransactionID   pgtype.Text        `json:"transaction_id"`
	TransactionDate pgtype.Date        `json:"transaction_date"`
	CashType        string             `json:"cash_type"`
	AmountMicros    int64              `json:"amount_micros"`
	SecurityID      pgtype.Text        `json:"security_id"`
	Description     pgtype.Text        `json:"description"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
	Symbol          pgtype.Text        `json:"symbol"`
	SecurityName    pgtype.Text        `json:"security_name"`
}

func (q *Queries) ListCashTransactionsByDateRange(ctx context.Context, arg ListCashTransactionsByDateRangeParams) ([]ListCashTransactionsByDateRangeRow, error) {
	rows, err := q.db.Query(ctx, listCashTransactionsByDateRange, arg.AccountID, arg.StartDate, arg.EndDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListCashTransactionsByDateRangeRow{}
	for rows.Next() {
		var i ListCashTransactionsByDateRangeRow
		if err := rows.Scan(
			&i.ID,
			&i.AccountID,
			&i.TransactionID,
			&i.TransactionDate,
			&i.CashType,
			&i.AmountMicros,
			&i.SecurityID,
			&i.Description,
			&i.CreatedAt,
			&i.Symbol,
			&i.SecurityName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
